CREATE OR REPLACE FUNCTION F_FORM(pEVAL_CODE VARCHAR2,pYYYYMM VARCHAR2) RETURN  NUMBER AS
 PL_SELECT VARCHAR2(2000); 
 AMT1      NUMBER;
 PL_CURSOR INTEGER;
 PL_NUMBER INTEGER;
 PL_BINDYN INTEGER;
 PL_EVAL   VARCHAR2(02);
 PL_MON    VARCHAR2(06);
BEGIN
    PL_EVAL := pEVAL_CODE;  -- PARAMETER ASSIGN
    PL_MON  := pYYYYMM;     -- PARAMETER ASSIGN
--  해당 EVAL_CODE 의 값을 만들기 위한 공식을 읽어온다.  
    SELECT FORM 
    INTO   PL_SELECT
    FROM   EVAL
    WHERE  EVAL_CODE = pEVAL_CODE;
--  공식에 존재하는 ACCT_CODE 를 해당 ACCT_CODE 가 가진 값으로  변경해준다.
    FOR I IN (SELECT ACCT_CODE,MON_AMT
              FROM   ACCT_SUM
              WHERE  YYYYMM = PL_MON
    )
    LOOP
        PL_SELECT := REPLACE(PL_SELECT,I.ACCT_CODE,I.MON_AMT);
    END LOOP;
--  DBMS_SQL을 이용 SQL PARSING;
    PL_SELECT := 'SELECT ' ||PL_SELECT||' FROM DUAL';
    PL_CURSOR := DBMS_SQL.OPEN_CURSOR;
    DBMS_SQL.PARSE(PL_CURSOR,PL_SELECT,DBMS_SQL.NATIVE);    
    DBMS_SQL.DEFINE_COLUMN(PL_CURSOR,1,AMT1);
    PL_NUMBER := DBMS_SQL.EXECUTE(PL_CURSOR);
    PL_NUMBER := DBMS_SQL.FETCH_ROWS(PL_CURSOR);    
    IF PL_NUMBER > 0 THEN
      DBMS_SQL.COLUMN_VALUE(PL_CURSOR,1,AMT1);
      DBMS_SQL.CLOSE_CURSOR(PL_CURSOR);
      RETURN AMT1;    
    ELSE 
    DBMS_SQL.CLOSE_CURSOR(PL_CURSOR);
    RETURN NULL;
    END IF;
EXCEPTION
     WHEN OTHERS THEN    
     IF DBMS_SQL.IS_OPEN(PL_CURSOR) THEN    
        DBMS_SQL.CLOSE_CURSOR(PL_CURSOR);
     END IF;
     RETURN NULL;
END;